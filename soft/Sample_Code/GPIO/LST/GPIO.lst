C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:35:02 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(FOSC_1
                    -60000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) OBJECT(.\Output\GPIO.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_define.h"
   4          #include "Common.h"
   5          #include "Delay.h"
   6          
   7          #define row1 P00
   8          #define row2 P01
   9          #define row3 P02
  10          #define row4 P03
  11          #define row5 P04
  12          
  13          #define col1 P10
  14          #define col2 P11
  15          #define col3 P12
  16          #define col4 P13
  17          #define col5 P14
  18          #define col6 P15
  19          #define col7 P16
  20          #define col8 P17
  21          
  22          unsigned char xdata ADCdataH[20], ADCdataL[20];
  23          UINT8 ADCsumH, ADCsumL;
  24          unsigned int i, while_times = 0;
  25          float ADCavg, ButterymV;
  26          
  27          //void Timer0_ISR(void) interrupt 1 //interrupt address is 0x000B
  28          //{                                                               // 8192/(16000000/12) = 0.006144s = 6.144ms
  29          
  30          //}
  31          
  32          unsigned char xdata allKey[5]; // 40个位，保存所有40个建的状态
  33          
  34          UINT8 tttt = 0;
  35          UINT16 TH1_INIT = 60000;                  // 系统时钟     16000 / 16000000 = 0.001s
  36                                                                            // 系统时钟1/12 1333 / 1333333 = 0.001s
  37          void Timer1_ISR(void) interrupt 3 //interrupt address is 0x001B
  38          {
  39   1              TH1 = (65536 - TH1_INIT) / 256;
  40   1              TL1 = (65536 - TH1_INIT) % 256;
  41   1      
  42   1              // row1到row5依次拉低
  43   1              P0 = 0xFF;
  44   1              if (tttt == 5)  //所有键扫描完成
  45   1              {
  46   2                      tttt = 0;
  47   2                      for (i = 0; i < 5; i++)
  48   2                      {
  49   3                              Send_Data_To_UART0(allKey[i]);
  50   3                      }
  51   2              }
  52   1              else
  53   1              {
  54   2                      if (tttt == 0)
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:35:02 PAGE 2   

  55   2                              P00 = 0;
  56   2                      if (tttt == 1)
  57   2                              P01 = 0;
  58   2                      if (tttt == 2)
  59   2                              P02 = 0;
  60   2                      if (tttt == 3)
  61   2                              P03 = 0;
  62   2                      if (tttt == 4)
  63   2                              P04 = 0;
  64   2      
  65   2                      allKey[tttt] = ~P1;
  66   2                      
  67   2                      // Send_Data_To_UART0(tttt);
  68   2                      // Send_Data_To_UART0(P0);
  69   2                      
  70   2                      // // 判断col1到col8的状态
  71   2                      // // Send_Data_To_UART0(~P1);
  72   2                      // Send_Data_To_UART0(allKey[tttt]);
  73   2      
  74   2                      tttt++;
  75   2              }
  76   1      }
  77          
  78          void main(void)
  79          {
  80   1              ///////////////////////////////////WDT///////////////////////////////////////
  81   1              TA = 0xAA;
  82   1              TA = 0x55;
  83   1              WDCON = 0x07; //Setting WDT prescale
  84   1              set_WDTR;        //WDT run
  85   1              set_WDCLR;      //Clear WDT timer
  86   1              set_EWDT;
  87   1              EA = 1;
  88   1              //set_WIDPD;
  89   1              /////////////////////////////////////////////////////////////////////////////
  90   1      
  91   1              Set_All_GPIO_Quasi_Mode;
  92   1              
  93   1              P00_PushPull_Mode;
  94   1              P01_PushPull_Mode;
  95   1              P02_PushPull_Mode;
  96   1              P03_PushPull_Mode;
  97   1              P04_PushPull_Mode;
  98   1      
  99   1              // TIMER0_MODE0_ENABLE;
 100   1              // set_ET0; //enable Timer0 interrupt
 101   1              // set_EA;  //enable interrupts
 102   1              // set_TR0; //Timer0 run
 103   1      
 104   1              TIMER1_MODE1_ENABLE;
 105   1              // set_T1M;
 106   1              TH1 = (65536 - TH1_INIT) / 256;
 107   1              TL1 = (65536 - TH1_INIT) % 256;
 108   1              set_ET1; //enable Timer1 interrupt
 109   1              set_EA;  //enable interrupts
 110   1              set_TR1; //Timer1 run
 111   1      
 112   1              InitialUART0_Timer3(115200);
 113   1              // Enable_ADC_AIN1; // Enable AIN0 as ADC input, Find in "Function_define.h" - "ADC INIT"
 114   1              // Enable_ADC_AIN7;
 115   1      
 116   1              while (1)
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:35:02 PAGE 3   

 117   1              {
 118   2                      set_WDCLR; // 喂狗
 119   2      
 120   2                      // P04 = ~P04;
 121   2              }
 122   1      
 123   1              //
 124   1              //      while (1)
 125   1              //      {
 126   1              //              while_times++;
 127   1              //              set_WDCLR; // 喂狗
 128   1      
 129   1              //              clr_ADCF;
 130   1              //              set_ADCS; // ADC start trig signal
 131   1              //              while (ADCF == 0)
 132   1              //                      ;
 133   1              //              ADCdataH[ADCsumH] = ADCRH;
 134   1              //              ADCdataL[ADCsumL] = ADCRL;
 135   1              //              ADCsumH++;
 136   1              //              ADCsumL++;
 137   1              //              if (ADCsumH == 20)
 138   1              //              {
 139   1              //                      ADCsumH = 0;
 140   1              //                      ADCsumL = 0;
 141   1              //                      for (i = 0; i < 20; i++)
 142   1              //                      {
 143   1              //                              ADCavg = ADCavg + (ADCdataH[i] * 16 + ADCdataL[i]);
 144   1              //                      }
 145   1              //                      ADCavg = ADCavg / 20;
 146   1              //                      ButterymV = 10000 * ADCavg / 4096;
 147   1              //                      ADCavg = 0;
 148   1              //              }
 149   1              //
 150   1      
 151   1              //
 152   1      
 153   1              //
 154   1              //              if (ButterymV > 7800)
 155   1              //              {
 156   1              //                      beforeAlready_9V = 1;
 157   1              //              }
 158   1              //              if (ButterymV < 7800)
 159   1              //              {
 160   1              //              }
 161   1              //              if (ButterymV >= 6300)
 162   1              //              {
 163   1              //                      WorkVoltageIsOK = 1;
 164   1              //                      beforeAlready_6300mV = 1;
 165   1      
 166   1              //              }
 167   1              //              if (ButterymV < 6000)
 168   1              //              {
 169   1              //                      // if (!beforeAlready_6300mV) { //防止电压跳变的时候触发断水保护
 170   1              //                              WorkVoltageIsOK = 0;
 171   1              //                      // }
 172   1              //              }
 173   1      
 174   1              //
 175   1              //              Timer1_Delay1ms(1);
 176   1              //#if 0
 177   1              //              if (while_times % 50 == 0)
 178   1              //              {
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:35:02 PAGE 4   

 179   1              //                      printf("\n%f s", loop_flush / 163.0);
 180   1              //                      printf("\nAllOff: %d", loopFlushAllOff);
 181   1              //
 182   1              //                      printf("\nButtery: %0.0f mV\n", ButterymV);
 183   1      
 184   1              //                      if (A_is_open)
 185   1              //                              printf("A:1  ");
 186   1              //                      else
 187   1              //                              printf("A:0  ");
 188   1      
 189   1              //                      if (B_is_open)
 190   1              //                              printf("B:1\n");
 191   1              //                      else
 192   1              //                              printf("B:0\n");
 193   1      
 194   1              //                      if (LED)
 195   1              //                              printf("LED: 1\n");
 196   1              //                      else
 197   1              //                              printf("LED: 0\n");
 198   1      
 199   1              //                      if (Start)
 200   1              //                              printf("start: 1\n");
 201   1              //                      else
 202   1              //                              printf("start: 0\n");
 203   1      
 204   1              //                      if (hold)
 205   1              //                              printf("hold:  1\n");
 206   1              //                      else
 207   1              //                              printf("hold:  0\n");
 208   1              //              }
 209   1              //#endif
 210   1              //      }
 211   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    444    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
