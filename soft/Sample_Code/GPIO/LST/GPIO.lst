C51 COMPILER V9.56.0.0   GPIO                                                              03/26/2020 22:55:56 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(FOSC_1
                    -60000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) OBJECT(.\Output\GPIO.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_define.h"
   4          #include "Common.h"
   5          #include "Delay.h"
   6          #include <string.h>
   7          #include "keyMap.h"
   8          
   9          // #define row1 P00
  10          // #define row2 P01
  11          // #define row3 P02
  12          // #define row4 P03
  13          // #define row5 P04
  14          
  15          // #define col1 P10
  16          // #define col2 P11
  17          // #define col3 P12
  18          // #define col4 P13
  19          // #define col5 P14
  20          // #define col6 P15
  21          // #define col7 P16
  22          // #define col8 P17
  23          
  24          unsigned int i, j;
  25          unsigned char xdata beforeAllKey[5]; // 40个位，保存上一次所有40个建的状态
  26          unsigned char xdata allKey[5];           // 40个位，保存当前所有40个建的状态
  27          
  28          unsigned int kCode;
  29          unsigned char xdata HIDFrames[8];
  30          unsigned int HIDFramesPointer = 2; // 从帧的第三个字节开始添加普通按键的KeyCode
  31          
  32          UINT8 tttt = 0;
  33          UINT16 TH1_INIT = 333;
  34          
  35          void makeHIDFrames(void)
  36          {
  37   1              HIDFramesPointer = 2;
  38   1              for (i = 0; i < 8; i++)
  39   1              {
  40   2                      HIDFrames[i] = 0;
  41   2              }
  42   1              if (allKey[0] == 0 && allKey[1] == 0 && allKey[2] == 0 && allKey[3] == 0 && allKey[4] == 0)
  43   1              { // 所有按键都是松开的状态
  44   2                      for (i = 0; i < 8; i++)
  45   2                      {
  46   3                              Send_Data_To_UART0(0x00);
  47   3                      }
  48   2              }
  49   1              else
  50   1              { // 有按键按下的状态
  51   2                      for (i = 0; i < 5; i++)
  52   2                      {
  53   3                              if (allKey[i] != 0)
  54   3                              {
C51 COMPILER V9.56.0.0   GPIO                                                              03/26/2020 22:55:56 PAGE 2   

  55   4                                      for (j = 0; j < 8; j++)
  56   4                                      {
  57   5                                              if (allKey[i] >> j & 1)
  58   5                                              {
  59   6                                                      kCode = keyMap[i * 8 + j];
  60   6                                                      // if (kCode == KEY_LCTRL | kCode == KEY_LSHIFT | kCode == KEY_LALT | kCode == KEY_LGUI | kCode == K
             -EY_RCTRL | kCode == KEY_RSHIFT | kCode == KEY_RALT | kCode == KEY_RGUI)
  61   6                                                      if (kCode >= 0xE0) // Control
  62   6                                                      {
  63   7                                                              HIDFrames[0] += 0X01 << (kCode & 0X0F);
  64   7                                                      }
  65   6                                                      else if (kCode >= 0xC0)
  66   6                                                      {
  67   7                                                              HIDFrames[0] += 0x02;
  68   7                                                              HIDFrames[HIDFramesPointer] = kCode-0xa2;
  69   7                                                              HIDFramesPointer++;
  70   7                                                      }
  71   6                                                      else
  72   6                                                      {
  73   7                                                              HIDFrames[HIDFramesPointer] = kCode;
  74   7                                                              HIDFramesPointer++;
  75   7                                                      }
  76   6                                              }
  77   5                                      }
  78   4                              }
  79   3                      }
  80   2                      for (i = 0; i < 8; i++)
  81   2                      {
  82   3                              Send_Data_To_UART0(HIDFrames[i]);
  83   3                      }
  84   2              }
  85   1      }
  86          
  87          // 系统时钟      16000 / 16000000 = 0.001s
  88          // 系统时钟1/12  1333  / 1333333  = 0.001s
  89          void Timer1_ISR(void) interrupt 3 //interrupt address is 0x001B
  90          {
  91   1              TH1 = (65536 - TH1_INIT) / 256;
  92   1              TL1 = (65536 - TH1_INIT) % 256;
  93   1      
  94   1              // row1到row5依次拉低
  95   1              P0 = 0xFF;
  96   1              if (tttt == 5) //所有键扫描完成
  97   1              {
  98   2                      tttt = 0;
  99   2                      if (memcmp(beforeAllKey, allKey, 5) != 0)
 100   2                      {
 101   3                              memcpy(beforeAllKey, allKey, 5);
 102   3      
 103   3                              makeHIDFrames();
 104   3                              // Send_Data_To_UART0(allKey[i]);
 105   3                      }
 106   2              }
 107   1              else
 108   1              {
 109   2                      if (tttt == 0)
 110   2                              P00 = 0;
 111   2                      if (tttt == 1)
 112   2                              P01 = 0;
 113   2                      if (tttt == 2)
 114   2                              P02 = 0;
 115   2                      if (tttt == 3)
C51 COMPILER V9.56.0.0   GPIO                                                              03/26/2020 22:55:56 PAGE 3   

 116   2                              P03 = 0;
 117   2                      if (tttt == 4)
 118   2                              P04 = 0;
 119   2      
 120   2                      allKey[tttt] = ~P1;
 121   2      
 122   2                      tttt++;
 123   2              }
 124   1      }
 125          
 126          void main(void)
 127          {
 128   1              ///////////////////////////////////WDT///////////////////////////////////////
 129   1              TA = 0xAA;
 130   1              TA = 0x55;
 131   1              WDCON = 0x07; //Setting WDT prescale
 132   1              set_WDTR;        //WDT run
 133   1              set_WDCLR;      //Clear WDT timer
 134   1              set_EWDT;
 135   1              EA = 1;
 136   1              //set_WIDPD;
 137   1              /////////////////////////////////////////////////////////////////////////////
 138   1      
 139   1              Set_All_GPIO_Quasi_Mode;
 140   1      
 141   1              P00_PushPull_Mode;
 142   1              P01_PushPull_Mode;
 143   1              P02_PushPull_Mode;
 144   1              P03_PushPull_Mode;
 145   1              P04_PushPull_Mode;
 146   1      
 147   1              TIMER1_MODE1_ENABLE;
 148   1              // set_T1M;
 149   1              TH1 = (65536 - TH1_INIT) / 256;
 150   1              TL1 = (65536 - TH1_INIT) % 256;
 151   1              set_ET1; //enable Timer1 interrupt
 152   1              set_EA;  //enable interrupts
 153   1              set_TR1; //Timer1 run
 154   1      
 155   1              InitialUART0_Timer3(115200);
 156   1              // Enable_ADC_AIN1; // Enable AIN0 as ADC input, Find in "Function_define.h" - "ADC INIT"
 157   1              // Enable_ADC_AIN7;
 158   1      
 159   1              while (1)
 160   1              {
 161   2                      set_WDCLR; // 喂狗
 162   2              }
 163   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    785    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     18    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
