C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:11:43 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(FOSC_1
                    -60000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) OBJECT(.\Output\GPIO.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_define.h"
   4          #include "Common.h"
   5          #include "Delay.h"
   6          
   7          #define row1 P00
   8          #define row2 P01
   9          #define row3 P02
  10          #define row4 P03
  11          #define row5 P04
  12          
  13          #define col1 P10
  14          #define col2 P11
  15          #define col3 P12
  16          #define col4 P13
  17          #define col5 P14
  18          #define col6 P15
  19          #define col7 P16
  20          #define col8 P17
  21          
  22          unsigned char xdata ADCdataH[20], ADCdataL[20];
  23          UINT8 ADCsumH, ADCsumL;
  24          unsigned int i, while_times = 0;
  25          float ADCavg, ButterymV;
  26          
  27          unsigned int beforeAlready_9V = 0;       //之前已经有9V
  28          unsigned int beforeAlready_6300mV = 0; //之前已经有6.3V
  29          
  30          unsigned int WorkVoltageIsOK = 0;
  31          
  32          //void Timer0_ISR(void) interrupt 1 //interrupt address is 0x000B
  33          //{                                                               // 8192/(16000000/12) = 0.006144s = 6.144ms
  34          
  35          //}
  36          
  37          unsigned char xdata allKey[5]; // 40个位，保存所有40个建的状态
  38          
  39          UINT8 tttt = 0;
  40          UINT16 TH1_INIT = 65535;                  // 系统时钟     16000 / 16000000 = 0.001s
  41                                                                            // 系统时钟1/12 1333 / 1333333 = 0.001s
  42          void Timer1_ISR(void) interrupt 3 //interrupt address is 0x001B
  43          {
  44   1              TH1 = (65536 - TH1_INIT) / 256;
  45   1              TL1 = (65536 - TH1_INIT) % 256;
  46   1      
  47   1              // row1到row5依次拉低
  48   1              P0 = 0xFF;
  49   1              if (tttt == 5)
  50   1              {
  51   2                      tttt = 0;
  52   2              }
  53   1              else
  54   1              {
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:11:43 PAGE 2   

  55   2                      if (tttt == 0)
  56   2                              P00 = 0;
  57   2                      if (tttt == 1)
  58   2                              P01 = 0;
  59   2                      if (tttt == 2)
  60   2                              P02 = 0;
  61   2                      if (tttt == 3)
  62   2                              P03 = 0;
  63   2                      if (tttt == 4)
  64   2                              P04 = 0;
  65   2      
  66   2                      allKey[tttt] = ~P0;
  67   2      
  68   2                      Send_Data_To_UART0(tttt);
  69   2                      Send_Data_To_UART0(P0);
  70   2      
  71   2                      // 判断col1到col8的状态
  72   2                      Send_Data_To_UART0(~P1);
  73   2      
  74   2                      tttt++;
  75   2              }
  76   1      }
  77          
  78          void main(void)
  79          {
  80   1              ///////////////////////////////////WDT///////////////////////////////////////
  81   1              TA = 0xAA;
  82   1              TA = 0x55;
  83   1              WDCON = 0x07; //Setting WDT prescale
  84   1              set_WDTR;        //WDT run
  85   1              set_WDCLR;      //Clear WDT timer
  86   1              set_EWDT;
  87   1              EA = 1;
  88   1              //set_WIDPD;
  89   1              /////////////////////////////////////////////////////////////////////////////
  90   1      
  91   1              Set_All_GPIO_Quasi_Mode; // Define in Function_define.h
  92   1              // P00_PushPull_Mode;
  93   1              // P10_PushPull_Mode;
  94   1              // P11_PushPull_Mode;
  95   1              // P12_PushPull_Mode;
  96   1              // P00 = 0;
  97   1              // P10 = 0;
  98   1              // P11 = 0;
  99   1              // P12 = 0;
 100   1      
 101   1              P00_PushPull_Mode;
 102   1              P01_PushPull_Mode;
 103   1              P02_PushPull_Mode;
 104   1              P03_PushPull_Mode;
 105   1              P04_PushPull_Mode;
 106   1      
 107   1              P0 = 0xe0;
 108   1      
 109   1              //P10_Input_Mode;
 110   1              //P11_Input_Mode;
 111   1              //P12_Input_Mode;
 112   1              //P13_Input_Mode;
 113   1              //P14_Input_Mode;
 114   1              //P15_Input_Mode;
 115   1              //P16_Input_Mode;
 116   1              //P17_Input_Mode;
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:11:43 PAGE 3   

 117   1              //P1=0x00;
 118   1      
 119   1              //P10_OpenDrain_Mode;
 120   1              //P11_OpenDrain_Mode;
 121   1              //P12_OpenDrain_Mode;
 122   1              //P13_OpenDrain_Mode;
 123   1              //P14_OpenDrain_Mode;
 124   1              //P15_OpenDrain_Mode;
 125   1              //P16_OpenDrain_Mode;
 126   1              //P17_OpenDrain_Mode;
 127   1      
 128   1              //P10=0;
 129   1              // P03_PushPull_Mode;
 130   1              // P03_Quasi_Mode;
 131   1              // P30_PushPull_Mode;
 132   1      
 133   1              // P04_Input_Mode;
 134   1              // P04_Quasi_Mode;
 135   1              // P04_PushPull_Mode;
 136   1      
 137   1              // TIMER0_MODE0_ENABLE;
 138   1              // set_ET0; //enable Timer0 interrupt
 139   1              // set_EA;  //enable interrupts
 140   1              // set_TR0; //Timer0 run
 141   1      
 142   1              TIMER1_MODE1_ENABLE;
 143   1              // set_T1M;
 144   1              TH1 = (65536 - TH1_INIT) / 256;
 145   1              TL1 = (65536 - TH1_INIT) % 256;
 146   1              set_ET1; //enable Timer1 interrupt
 147   1              set_EA;  //enable interrupts
 148   1              set_TR1; //Timer1 run
 149   1      
 150   1              InitialUART0_Timer3(115200);
 151   1              // Enable_ADC_AIN1; // Enable AIN0 as ADC input, Find in "Function_define.h" - "ADC INIT"
 152   1              // Enable_ADC_AIN7;
 153   1      
 154   1              while (1)
 155   1              {
 156   2                      set_WDCLR; // 喂狗
 157   2      
 158   2                      // P04 = ~P04;
 159   2              }
 160   1      
 161   1              //
 162   1              //      while (1)
 163   1              //      {
 164   1              //              while_times++;
 165   1              //              set_WDCLR; // 喂狗
 166   1      
 167   1              //              clr_ADCF;
 168   1              //              set_ADCS; // ADC start trig signal
 169   1              //              while (ADCF == 0)
 170   1              //                      ;
 171   1              //              ADCdataH[ADCsumH] = ADCRH;
 172   1              //              ADCdataL[ADCsumL] = ADCRL;
 173   1              //              ADCsumH++;
 174   1              //              ADCsumL++;
 175   1              //              if (ADCsumH == 20)
 176   1              //              {
 177   1              //                      ADCsumH = 0;
 178   1              //                      ADCsumL = 0;
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:11:43 PAGE 4   

 179   1              //                      for (i = 0; i < 20; i++)
 180   1              //                      {
 181   1              //                              ADCavg = ADCavg + (ADCdataH[i] * 16 + ADCdataL[i]);
 182   1              //                      }
 183   1              //                      ADCavg = ADCavg / 20;
 184   1              //                      ButterymV = 10000 * ADCavg / 4096;
 185   1              //                      ADCavg = 0;
 186   1              //              }
 187   1              //
 188   1      
 189   1              //
 190   1      
 191   1              //
 192   1              //              if (ButterymV > 7800)
 193   1              //              {
 194   1              //                      beforeAlready_9V = 1;
 195   1              //              }
 196   1              //              if (ButterymV < 7800)
 197   1              //              {
 198   1              //              }
 199   1              //              if (ButterymV >= 6300)
 200   1              //              {
 201   1              //                      WorkVoltageIsOK = 1;
 202   1              //                      beforeAlready_6300mV = 1;
 203   1      
 204   1              //              }
 205   1              //              if (ButterymV < 6000)
 206   1              //              {
 207   1              //                      // if (!beforeAlready_6300mV) { //防止电压跳变的时候触发断水保护
 208   1              //                              WorkVoltageIsOK = 0;
 209   1              //                      // }
 210   1              //              }
 211   1      
 212   1              //
 213   1              //              Timer1_Delay1ms(1);
 214   1              //#if 0
 215   1              //              if (while_times % 50 == 0)
 216   1              //              {
 217   1              //                      printf("\n%f s", loop_flush / 163.0);
 218   1              //                      printf("\nAllOff: %d", loopFlushAllOff);
 219   1              //
 220   1              //                      printf("\nButtery: %0.0f mV\n", ButterymV);
 221   1      
 222   1              //                      if (A_is_open)
 223   1              //                              printf("A:1  ");
 224   1              //                      else
 225   1              //                              printf("A:0  ");
 226   1      
 227   1              //                      if (B_is_open)
 228   1              //                              printf("B:1\n");
 229   1              //                      else
 230   1              //                              printf("B:0\n");
 231   1      
 232   1              //                      if (LED)
 233   1              //                              printf("LED: 1\n");
 234   1              //                      else
 235   1              //                              printf("LED: 0\n");
 236   1      
 237   1              //                      if (Start)
 238   1              //                              printf("start: 1\n");
 239   1              //                      else
 240   1              //                              printf("start: 0\n");
C51 COMPILER V9.56.0.0   GPIO                                                              03/11/2020 21:11:43 PAGE 5   

 241   1      
 242   1              //                      if (hold)
 243   1              //                              printf("hold:  1\n");
 244   1              //                      else
 245   1              //                              printf("hold:  0\n");
 246   1              //              }
 247   1              //#endif
 248   1              //      }
 249   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    424    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     45    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
